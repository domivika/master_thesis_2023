# Define paths to references and directories
reference = "/lustre1/project/stg_00096/references/GRCh38.alt-masked-V2/index/bwa-mem2/Homo_sapiens_assembly38_masked.fasta"
known_sites = "/staging/leuven/stg_00096/references/GRCh38.alt-masked-V2/annotation/snv_indel/gnomAD_v3.1.2/small-gnomad-common-GRCexcl.genomes.v3.1.2.sites.all.vcf.bgz"
GATK_path = "/staging/leuven/stg_00096/software/singularity/gatk_4.2.6.1.sif"
work_dir = "/staging/leuven/stg_00096/home/dkresa/ResolveOME/single_cell/230623.NovaSeq2.FCA/1277"
stage_dir = "/staging/leuven/stg_00096"
lustre_dir = "/lustre1/project/stg_00096"
scratch_dir = "/scratch/leuven/343/vsc34319"

# Define global wildcards
files = glob_wildcards("/staging/leuven/stg_00096/home/dkresa/ResolveOME/single_cell/230623.NovaSeq2.FCA/1277/{sample}_L00{l}_R{r}_001.fastq.gz")
fq1 = glob_wildcards("/staging/leuven/stg_00096/home/dkresa/ResolveOME/single_cell/230623.NovaSeq2.FCA/1277/{sample}_L00{l}_R1_001.fastq.gz")
fq2 = glob_wildcards("/staging/leuven/stg_00096/home/dkresa/ResolveOME/single_cell/230623.NovaSeq2.FCA/1277/{sample}_L00{l}_R2_001.fastq.gz")


# Define output files
fastqc_output = expand("QC/1_premap/fastqc/{sample}_L00{l}_R{r}_001_fastqc.html", zip, sample=files.sample, l=files.l, r=files.r)
multiqc_output = "QC/1_premap/multiqc/multiqc_report.html"
bwa_mem2_output = expand("raw_bams/{sample}_L00{l}.bam", zip, sample=files.sample, l=files.l)
sort_bam_files_output = expand("raw_bams/{sample}_L00{l}.sorted.bam", zip, sample=files.sample, l=files.l)
mark_duplicates_output = expand("raw_bams/{sample}_L00{l}.sorted.marked.bam", zip, sample=files.sample, l=files.l)
base_recalibrator_output = expand("recalibrated/{sample}_L00{l}.recal_data.table", zip, sample=files.sample, l=files.l)
apply_bqsr_output = expand("recalibrated/{sample}_L00{l}.sorted.marked.recal.bam", zip, sample=files.sample, l=files.l)
merge_sorted_bam_output = expand("bam/{sample}.bam", sample=files.sample)
haplotype_calling_output = expand("gvcf/{sample}.g.vcf.gz", sample=files.sample)
combine_gvcfs_output = "database"
joint_genotyping_output = "vcf/cohort.vcf"

# Define output reports
bwa_mem2_report = expand("raw_bams/reports/bwa_mem2/{sample}_L00{l}.txt", zip, sample=files.sample, l=files.l)
sort_bam_files_report = expand("raw_bams/reports/sort_bam_files/{sample}_L00{l}.txt", zip, sample=files.sample, l=files.l)
mark_duplicates_report = expand("raw_bams/reports/mark_duplicates/{sample}_L00{l}.txt", zip, sample=files.sample, l=files.l)
base_recalibrator_report = expand("recalibrated/reports/base_recalibrator/{sample}_L00{l}.txt", zip, sample=files.sample, l=files.l)
apply_bqsr_report = expand("recalibrated/reports/apply_bqsr/{sample}_L00{l}.txt", zip, sample=files.sample, l=files.l)
merge_sorted_bam_report = expand("bam/reports/merge_sorted_bam/{sample}.txt", sample=files.sample)
haplotype_calling_report = expand("gvcf/reports/haplotype_calling/{sample}.txt", sample=files.sample)
combine_gvcfs_report = "gvcf/reports/combine_gvcfs.txt"
joint_genotyping_report = "vcf/reports/joint_genotyping.txt"


rule all:
    input:
        fastqc_output,
        multiqc_output,
        bwa_mem2_output,
        bwa_mem2_report,
        sort_bam_files_output,
        sort_bam_files_report,
        mark_duplicates_output,
        mark_duplicates_report,
        base_recalibrator_output,
        base_recalibrator_report,
        apply_bqsr_output,
        apply_bqsr_report,
        merge_sorted_bam_output,
        merge_sorted_bam_report,
        haplotype_calling_output,
        haplotype_calling_report,
        combine_gvcfs_output,
        combine_gvcfs_report,
        joint_genotyping_output,
        joint_genotyping_report


# Rule for quality control (FastQC):
rule fastqc:
    input:
        fq = "/staging/leuven/stg_00096/home/dkresa/ResolveOME/single_cell/230623.NovaSeq2.FCA/1277/{sample}_L00{l}_R{r}_001.fastq.gz"
    output:
        zip = "QC/1_premap/fastqc/{sample}_L00{l}_R{r}_001_fastqc.zip",
        html = "QC/1_premap/fastqc/{sample}_L00{l}_R{r}_001_fastqc.html"
    threads: 1
    shell:
        """
        echo "Input Fastq: {input.fq}"
        fastqc -o QC/1_premap/fastqc {input.fq}
        """

# Rule for generating MultiQC report
rule multiqc:
    input:
        report_files = fastqc_output
    output:
        html_report = "QC/1_premap/multiqc/multiqc_report.html"
    threads: 24
    shell:
        """
        multiqc QC/1_premap/fastqc -o QC/1_premap/multiqc
        """

# Rule for BWA MEM2 alignment
rule bwa_mem2:
    input:
        fq1 = "/staging/leuven/stg_00096/home/dkresa/ResolveOME/single_cell/230623.NovaSeq2.FCA/1277/{sample}_L00{l}_R1_001.fastq.gz",
        fq2 = "/staging/leuven/stg_00096/home/dkresa/ResolveOME/single_cell/230623.NovaSeq2.FCA/1277/{sample}_L00{l}_R2_001.fastq.gz",
        ref = reference,
        report_files = multiqc_output
    threads: 24
    output:
        bam = "raw_bams/{sample}_L00{l}.bam",
        task_done = "raw_bams/reports/bwa_mem2/{sample}_L00{l}.txt"
    shell:
        """
        /lustre1/project/stg_00096/software/bwa-mem2-2.2.1_x64-linux/bwa-mem2 mem \
        -t {threads} \
        -M \
        -R "@RG\\tID:{wildcards.sample}\\tPL:ILLUMINA\\tSM:{wildcards.sample}" {input.ref} \
        {input.fq1} {input.fq2} \
        | samtools view -Sb -> {output.bam}

        touch {output.task_done}
        """

# Rule for sorting BAM files by queryname
rule sort_bam_files:
    input:
        bam = "raw_bams/{sample}_L00{l}.bam",
        check_input = bwa_mem2_report
    output:
        sorted_bam = "raw_bams/{sample}_L00{l}.sorted.bam",
        task_done = "raw_bams/reports/sort_bam_files/{sample}_L00{l}.txt"
    threads: 24
    shell:
        """
        java -jar $EBROOTPICARD/picard.jar SortSam \
        -I {input.bam} \
        -O {output.sorted_bam} \
        --SORT_ORDER queryname

        touch {output.task_done}
        """

# Rule for marking duplicates
rule mark_duplicates:
    input:
        bam = "raw_bams/{sample}_L00{l}.sorted.bam",
        check_input = sort_bam_files_report
    output:
        marked_bam = "raw_bams/{sample}_L00{l}.sorted.marked.bam",
        task_done = "raw_bams/reports/mark_duplicates/{sample}_L00{l}.txt"
    params:
        gatk = GATK_path,
        stage = stage_dir,
        lustre = lustre_dir
    threads: 24
    shell:
        """        
        singularity run --nv \
        -B {params.stage} \
        -B {params.lustre} \
        {params.gatk} gatk MarkDuplicatesSpark \
        -I {input.bam} \
        -O {output.marked_bam} \
        -M {output.marked_bam}.metrics.txt

        touch {output.task_done}
        """

# Rule for base quality score recalibration
rule base_recalibrator:
    input:
        marked_bam = "raw_bams/{sample}_L00{l}.sorted.marked.bam",
        ref = reference,
        dbsnp = known_sites,
        check_input = mark_duplicates_report
    output:
        data_table = "recalibrated/{sample}_L00{l}.recal_data.table",
        task_done = "recalibrated/reports/base_recalibrator/{sample}_L00{l}.txt"
    params:
        gatk = GATK_path,
        stage = stage_dir,
        lustre = lustre_dir
    threads: 2
    shell:
        """
        singularity run --nv \
        -B {params.stage} \
        -B {params.lustre} \
        {params.gatk} gatk BaseRecalibrator \
        -I {input.marked_bam} \
        -R {input.ref} \
        --known-sites {input.dbsnp} \
        -O {output.data_table}

        touch {output.task_done}
        """

# Rule for applying base quality score recalibration
rule apply_bqsr:
    input:
        marked_bam = "raw_bams/{sample}_L00{l}.sorted.marked.bam",
        recalibration_table = "recalibrated/{sample}_L00{l}.recal_data.table",
        ref = reference,
        check_input = base_recalibrator_report
    output:
        output_bam = "recalibrated/{sample}_L00{l}.sorted.marked.recal.bam",
        task_done = "recalibrated/reports/apply_bqsr/{sample}_L00{l}.txt"
    params:
        gatk = GATK_path,
        stage = stage_dir,
        lustre = lustre_dir
    threads: 2
    shell:
        """
        singularity run --nv \
        -B {params.stage} \
        -B {params.lustre} \
        {params.gatk} gatk ApplyBQSR \
        -R {input.ref} \
        -I {input.marked_bam} \
        --bqsr-recal-file {input.recalibration_table} \
        -O {output.output_bam}

        touch {output.task_done}
        """

rule merge_sorted_bam:
    input:
        bam_sorted_L1 = "recalibrated/{sample}_L001.sorted.marked.recal.bam",
        bam_sorted_L2 = "recalibrated/{sample}_L002.sorted.marked.recal.bam",
        bam_sorted_L3 = "recalibrated/{sample}_L003.sorted.marked.recal.bam",
        bam_sorted_L4 = "recalibrated/{sample}_L004.sorted.marked.recal.bam",
        report_L1 = "recalibrated/reports/apply_bqsr/{sample}_L001.txt",
        report_L2 = "recalibrated/reports/apply_bqsr/{sample}_L002.txt",
        report_L3 = "recalibrated/reports/apply_bqsr/{sample}_L003.txt",
        report_L4 = "recalibrated/reports/apply_bqsr/{sample}_L004.txt"
    output:
        merged_bam = "bam/{sample}.bam",
        task_done = "bam/reports/merge_sorted_bam/{sample}.txt"
    threads: 24
    shell:
        """
        sambamba merge -t {threads} {output.merged_bam} {input.bam_sorted_L1} {input.bam_sorted_L2} {input.bam_sorted_L3} {input.bam_sorted_L4}
        samtools index {output.merged_bam}

        touch {output.task_done}
        """

# Rule for haplotype calling
rule haplotype_calling:
    input:
        ref = reference,
        merged_bam = "bam/{sample}.bam",
        check_input = merge_sorted_bam_report
        
    output:
        gvcfs = "gvcf/{sample}.g.vcf.gz",
        task_done = "gvcf/reports/haplotype_calling/{sample}.txt"
    params:
        gatk = GATK_path,
        stage = stage_dir,
        lustre = lustre_dir
    threads: 2
    shell:
        """
        singularity run --nv \
        -B {params.stage} \
        -B {params.lustre} \
        {params.gatk} gatk --java-options "-Xmx4g" HaplotypeCaller \
        -R {input.ref} \
        -I {input.merged_bam} \
        -O {output.gvcfs} \
        -ERC GVCF

        touch {output.task_done}
        """

# Rule for GVCFs combining
#replace with GenomicsDBImport !
rule combine_gvcfs:
    input:
        ref = reference,
        check_input = haplotype_calling_report
    output:
        database_dir = "database",
        task_done = "gvcf/reports/combine_gvcfs.txt"
    params:
        gatk = GATK_path,
        stage = stage_dir,
        lustre = lustre_dir,
        tmp = scratch_dir,
        sample_map = "gvcf/sample.map",
        contigs = "gvcf/contigs.list"
    threads: 24
    log:
        "logs/genomicsdbimport.log"
    shell:
        """
        singularity run --nv \
        -B {params.stage} \
        -B {params.lustre} \
        {params.gatk} gatk --java-options "-Xmx250g" GenomicsDBImport \
        --genomicsdb-workspace-path database \
        -R {input.ref} \
        --sample-name-map {params.sample_map} \
        --intervals {params.contigs}

        touch {output.task_done}
        """

# Rule for joint genotyping
rule joint_genotyping:
    input:
        database = "database",
        ref = reference,
        check_input = combine_gvcfs_report
    output:
        merged_vcf = "vcf/cohort.vcf",
        task_done = "vcf/reports/joint_genotyping.txt"
    params:
        gatk = GATK_path,
        stage = stage_dir,
        lustre = lustre_dir
    threads: 24
    shell:
        """
        singularity run --nv \
        -B {params.stage} \
        -B {params.lustre} \
        {params.gatk} gatk --java-options "-Xmx250g" GenotypeGVCFs \
        -R {input.ref} \
        -V gendb://{input.database} \
        -O {output.merged_vcf}

        touch {output.task_done}
        """